



---
title: "Group11_CitiBike"
group members: Emily Chang, Robert Konigsberg, Mahraan Qadir, Jason Wang, Jiaxin Zheng, Xialin Zou
date: Due Feb. 15, 2016
output: html_document
---

```{r}

# declare libraries
library(plyr)
library(dplyr)
library(ggplot2)
library(ggmap)

# read in citibike data
citibike <- read.csv("201511-citibike-tripdata.csv")

```

#Patterns in Ride History Data
Identify patterns in the ride history data. Explain these patterns using appropriate visualization. Two potential patterns are (this is an illustrative list, you should formulate your own patterns as well to be explored here):

####1. Which stations see the most asymmetric traffic (more arrivals than departures and vice versa)?
```{r}
endStation<-as.data.frame(table(citiBike$end.station.id))
startStation<-as.data.frame(table(citiBike$start.station.id))
stationData <- merge(startStation, endStation, by="Var1", all=TRUE)
stationData[is.na(stationData)] <- 0
names(stationData) <- c("station.id", "start.freq", "end.freq")
stationData$inTraffic <- stationData$start.freq - stationData$end.freq
stationData$outTraffic <- stationData$end.freq - stationData$start.freq
```

The stations with the most outgoing traffic are:
```{r}
outTraffic <- stationData[order(-stationData$outTraffic),]
barplot(outTraffic$outTraffic[outTraffic$outTraffic > 300], main="Bike Stations with Highest Net Outflow of Bikes", names.arg = outTraffic$station.id[outTraffic$outTraffic > 300], xlab = "Station IDs", ylab = "Net Outflow (Bikes)")
```

The stations with the most incoming traffic are:
```{r}
inTraffic <- stationData[order(-stationData$inTraffic),]
barplot(inTraffic$inTraffic[inTraffic$inTraffic > 300], main="Bike Stations with Highest Net Inflow of Bikes", names.arg = inTraffic$station.id[inTraffic$inTraffic > 300], xlab = "Station IDs", ylab = "Net Inflow (Bikes)")
```


####2. Which stations originate the longest rides? Does this change as we go through different times of the day?
```{r}
longestRide <- aggregate(citiBike[, 1], list(citiBike$start.station.id), mean)
names(longestRide) <- c("station.id", "mean.trip.duration")
stationData <- merge(stationData, longestRide, by="station.id", all=TRUE)
stationData[is.na(stationData)] <- 0

longestRide <- stationData[order(-stationData$mean.trip.duration),]
barplot(longestRide$mean.trip.duration[longestRide$mean.trip.duration > 2000], main = "Stations that Originate the Longest Rides", names.arg = longestRide$station.id[longestRide$mean.trip.duration > 2000], xlab = "Station IDs", ylab = "Ride Duration")


```

#Dataset Visualization
```{r}

# change

# ===============================================================================
# ===============================[calculations]==================================
# ===============================================================================

# =============================[most used routes]================================

# function returns a unique integer from two integer inputs
cantor_pairing_function <- function(a, b){
  return(0.5 * (a + b) * (a + b + 1) + b)
}

# get all routes taken
routes <- subset(citibike, select = c(start.station.id, end.station.id, start.station.latitude, start.station.longitude, end.station.latitude, end.station.longitude))
colnames(routes) <- c("start.id", "end.id", "start.lat", "start.lon", "end.lat", "end.lon")

# apply unique route.id based on the cantor pairing function, with start.id and end.id as inputs
routes$route.id = cantor_pairing_function(routes$start.id, routes$end.id)

# count # of times a route has been used
route_counts <- routes %>%
  count(route.id)
colnames(route_counts) <- c("route.id", "route.count")

# get only unique routes
unique_routes <- unique(routes)

# merge route count with ids, lats, and longitudes
route_counts <- join(unique_routes, route_counts, by = "route.id", type = "full", match = "first")
route_counts <- subset(route_counts, select = -c(route.id) )

# sort by highest count 
route_counts <- route_counts[with(route_counts, order(-route.count)), ]

# =============================[station surplus]================================

# get arrivals to station
arrival_counts <- citibike %>%
  count(end.station.id)
colnames(arrival_counts) <- c("id", "arr")

# get departures from station
departure_counts <- citibike %>%
  count(start.station.id)
colnames(departure_counts) <- c("id", "dep")

# get unique stations
stations <- unique(subset(citibike, select = c(start.station.id, start.station.latitude, start.station.longitude)))
colnames(stations) <- c("id", "lat", "lon")

# merge arrivals and departures with list of stations
stations <- join(stations, arrival_counts, by = "id", type = "full", match = "first")
stations <- join(stations, departure_counts, by = "id", type = "full", match = "first")

# calculate surplus of station
stations$surplus = stations$arr - stations$dep

# seperate surplus and deficit stations
stations.surplus <- subset(stations, surplus >= 0)
stations.deficit <- subset(stations, surplus <= 0)


# ===============================================================================
# ==================================[mapping]====================================
# ===============================================================================

min_lat <- min(c(min(citibike$start.station.latitude), min(citibike$end.station.latitude))) + 0.025
max_lat <- max(c(max(citibike$start.station.latitude), max(citibike$end.station.latitude))) + 0.0055
min_lon <- min(c(min(citibike$start.station.longitude), min(citibike$end.station.longitude))) + 0.029
max_lon <- max(c(max(citibike$start.station.longitude), max(citibike$end.station.longitude))) + 0.005

nyc <- c(left = min_lon, bottom = min_lat, right = max_lon, top = max_lat)
basemap <- get_map(nyc, zoom = 13, maptype = "terrain", source = "stamen")

# =============================[most used routes]================================

# declare variables
routes_to_show <- 10
origin <- c()
dest <- c()

# get routes
for(i in 1:routes_to_show){
  origin <- append(origin, paste(routes$start.lat[i], routes$start.lon[i], sep=","))
  dest <- append(dest, paste(routes$end.lat[i], routes$end.lon[i], sep=","))
}

# initialize routes map
map.routes <- ggmap(basemap, base_layer = ggplot(stations, aes(x = lon, y = lat)))

# build routes map
for(i in 1:(routes_to_show)){
  k <- (i - 1) / routes_to_show
  map.routes <- map.routes +
    geom_path(aes(x = lon, y = lat), data = route(origin[i], dest[i], structure = "route"),
              color = "darkred", size = 2 - (k * (2 - 0.5)), alpha = 1 - (k * (1 - 0.5)))
}

# display route map
map.routes

# =============================[station surplus]================================

# build surplus stations map
map.surplus <- ggmap(basemap, base_layer = ggplot(stations.surplus, aes(x = lon, y = lat))) +
  geom_point(aes(color = surplus, size = surplus), alpha = .8) +
  scale_color_gradient(low = "green", high = "darkgreen") +
  scale_size(range = c(0.5, 10))

# build deficit stations map
map.deficit <- ggmap(basemap, base_layer = ggplot(stations.deficit, aes(x = lon, y = lat))) +
  geom_point(aes(color = surplus, size = surplus), alpha = .8) +
  scale_color_gradient(low = "darkred", high = "red") +
  scale_size(range = c(30, 1))

# display surplus and deficit maps
map.surplus
map.deficit


```


#Business Issues
####Stations running out of bikes is a big problem. Client would want to know which stations are candidates for improving bike storage capacity.

```{r}
# The stations that are start stations the most number of times are likely the best candidates for a higher bike storage capacity
startStationCount <- as.data.frame(table(citiBike$start.station.id))
startStationCount <- startStationCount[order(startStationCount$Freq, decreasing=TRUE),]
head(startStationCount)
```


####Bike maintenance bills are piling up. Client thinks that this is because some bikes are being used a lot more than other bikes. Can you check on this assumption?

####Client is planning a promotion to increase bike rental by younger folks (age < 25) and tourists (i.e not an annual member). They want to focus on stations that are less used by these target groups. Can you help them identify these stations?


```{r}
####Client is planning a promotion to increase bike rental by younger folks (age < 25) and tourists (i.e not an annual member). They want to focus on stations that are less used by these target groups. Can you help them identify these stations?
#Qu estion for group: should I combine these two groups into one demographic, or leave them separate?
#Some birth dates are kept empty, can't do anything in those situations. 
head(citiBike)
young.customers <- subset(citiBike, citiBike$birth.year > 1991)
young.startStation <- as.data.frame(table(young.customers$start.station.id))
head(young.startStation)
sorted.young <- young.startStation[order(young.startStation$Freq),]
head(sorted.young)
#It may be useful to classify stations "less used" as those with a certain frequency. This would mean taking a subset of sorted.young. 
#User type is either subscriber or customer, so I'm assuming tourists are customers
tourist.customers <- subset(citiBike,citiBike$usertype == "Customer")
tourist.startStation <- as.data.frame(table(tourist.customers$start.station.id))
head(tourist.startStation)
sorted.tourist <- tourist.startStation[order(tourist.startStation$Freq),]
head(sorted.tourist)
```














